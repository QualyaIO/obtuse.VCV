
// testing a tonnetz implementation using VCV.Prototype. Cannot use external files, so we will code here instead

/*

 getKnob(n:int) : real // value of the nth knob range: 0.0-1.0
 getSwitch(n:int) : bool // value of the nth switch: true/false

 setLight(n:int, r:real, g:real, b:real) // r, g, b range: 0.0-1.0
 setSwitchLight(n:int, r:real, g:real, b:real) // r, g, b range: 0.0-1.0

 samplerate() : real  // current sample rate
 sampletime() : real  // current time step (1.0 / samplerate())

 */


// super pow(), to overcome some limitation with vult
// TODO: check up to which point pow() really differs with fixed float
fun spow(base: real, x: real) {
  val log_base = log10(base)/log10(exp(1.0));
  return exp(log_base * x);
}

// compute cumulative beta for x [0..1] and a == 1
fun beta(x: real, b: real): real  {
  return 1.0 - spow((1.0 - x), b);
}
// generating chords using Tonnetz relationships

//    8 - - 3
//   / \   / \
// 5 - - 0 - - 7
//  \   / \   /
//    9 - - 4 

// generate a new chord depending on rules, returning three notes
fun tonnetz() {
  // which of the 12 notes is enabled or not in this scale. 0 being the root, it should be always true.
  mem scale: array(bool, 12); 
  // root note for the scale
  mem root: int;
  // chords probabilities, destined to be augmented, major, suspended 4, suspended 2, minor, diminished, but the array will be used as is [0] is the selected chord
  mem chords: array(real, 6);
  // main chord, index of chords
  mem chord: int;
  // up to which point we go beyond selected chord (0: no, 1: all)
  mem chordSpread: real;


  // temp hack to change chords at each call
  mem c;
  c = c + 1;
  if (c >= 12) {
      c = 0;
  }
  return root+c, root+4+c, root+7+c;
}

// choose from one of the scale
// 0: diatonic ionian (major)
//    5 - - 0 - - 7
//   / \   / \   / \   
// 2 - - 9 - - 4 - - 11

// 1: diatonic aeolian (minor)
//    8 - - 3 - - 10
//   / \   / \   / \   
// 5 - - 0 - - 7 - - 2

// won't change scale otherwise
and setScale(id: int) {
  // diatonic ionian (major)
  if (id == 0) {
    scale = [true, false, true, false, true, true, false, true, false, true, false, true];
  }
  // diatonic aeolian (minor)
  else if (id == 1) {
    scale = [true, false, true, true, false, true, false, true, true, false, true, false];
  }
}

// change root note
and setRoot(note: int) {
    root = clip(note, 0, 127);
}

// internally update the probability that each chord appears
// using cumulative beta function, 0 being selected chord and 1.0 the extreme opposite. Computed with regularized incomplete beta function, which, with a == 1 (what is wanted in orded to go from equiprobability with b == 1 to only select chord with b big), I_{x}(1,b) = 1 - (1 - x)^{b}

// bParam: b parameter in the beta distribution
and _updateChords(bParam: real) {
  bParam = clip(bParam, 0.0, bParam);

  // dismiss the easy case
  if (size(chords) == 1) {
    chords[0] = 1.0;
  }
  else {
    // since the chords "loop", will compute in two halves. max indice will depend on odd/even
    val maxi;
    if (size(chords) % 2 == 1) {
      maxi = (size(chords) - 1) / 2;
    } else {
      maxi = (size(chords) / 2) - 1;
    }

    // current chords index
    val i = 0;
    // where we are in the cumulative function, starting with selected chord
    val x = 1.0/real(size(chords));
    chords[i] = beta(x, bParam);
    // save base value for selected chord
    val chordP = chords[i];
                     
    // will scale to account for the fact that we aggregate two halves
    val scaleP = 0.0;
    scaleP = (1.0 - chordP) * (real(maxi) / real(size(chords)-1));

    // starting first half
    i = i + 1;
    while (i <= maxi) {
      x = real(i) / real(maxi);
      chords[i] = chordP + beta(x, bParam) * scaleP;
      i = i + 1;
    }

    // second half
    while (i < size(chords) - 1) {
      // index in this half
      if (size(chords) % 2 == 1) {
        x = real(i - maxi) / real(maxi);
      }
      else {
        x = real(i - maxi - 1) / real(maxi);
      }
      // inverse cumulative function here for symmetry, the center of the array being the furthest from selected chord [0]
      chords[i] = 1.0 - beta(1.0-x, bParam) * scaleP;
      i = i + 1;
    }

    // mandatory 1 for last
    chords[size(chords) - 1] = 1.0;
  }
}

// set main chord
// 0: augmented, 1: major, 2: suspended 4, 3: suspended 2, 4: minor, 5: diminished
and setChord(newChord: int) {
  chord = clip(newChord, 0, size(chords));
}

// up to which point other chords will be considered, from 0 (only selected chord) to 1 (all chords equi-probable)
// TODO: -1 for most distant chords only, or all chord but selected?
and setChordSpread(newSpread: real) {
    newSpread = clip(newSpread, 0.0, 1.0);
    if (newSpread <> chordSpread) {
      chordSpread = newSpread;
      // 0 will be map to b==100 (might actually leave *tiny* room for other chords), 1 to b==1
      val bParam = ((1.0 - newSpread) * 99.0) + 1.0;
        _ = _updateChords(bParam);
    }
}

and default() @[init] {
    // middle C by default
    _ = setRoot(60);
    // major
    _ = setChord(1); 
    // prefer selected chord
    _ = setChordSpread(0.5);
}

// from a midi note to cv -1..1
fun pitchToCv(pitch) {
    return (pitch - 60.0) / 120.0;
}

// intput and output (up to 6) normalized from -10/10v to -1/1
fun process() {
    // notes of the chords
    mem n1, n2, n3;

    return pitchToCv(real(n1)), pitchToCv(real(n2)), pitchToCv(real(n3)); 
}
// called once every 32 loops
and update() {
    // detecting first switch press
    mem lastSwitch;
    if (lastSwitch == 0 && getSwitch(1)) {
        lastSwitch = 1;
        n1, n2, n3 = tonnetz();
    }
    else if (not(getSwitch(1))) {
        lastSwitch = 0;
    }
    // some light feedback about switch press
    setSwitchLight(1, 0.0, real(lastSwitch * 255), 0.0);

    //_ = display("Press first switch to update chord");
    // hack to display several things alternatively
    mem disstep;
    disstep = disstep + 1;
    val disfreq = 1000;
    if (disstep % disfreq < disfreq / 2) {
        _ = display(string(spow(2.5, 2.2)));
    } else {
        _ = display(string(-3 % 4));
    }
}
