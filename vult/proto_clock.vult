
// testing a tonnetz implementation using VCV.Prototype. Cannot use external files, so we will code here instead

/*

 getKnob(n:int) : real // value of the nth knob range: 0.0-1.0
 getSwitch(n:int) : bool // value of the nth switch: true/false

 setLight(n:int, r:real, g:real, b:real) // r, g, b range: 0.0-1.0, i from 1 to 6
 setSwitchLight(n:int, r:real, g:real, b:real) // r, g, b range: 0.0-1.0

 samplerate() : real  // current sample rate
 sampletime() : real  // current time step (1.0 / samplerate())

 */



// clock with swing and grouping


// - . o . - . o . normal
// - o . . - o . .  swing -
// - . . o - . . o swing +
// - . - . - . - . o . o . o . o . normal groupe 4 ... ou 8 en fait. swing pour min groupe 2. ratio 0.5
// - - - - o . . o . . o . . o . .  swing -


// inform the whole world about supported BPM range
fun getMinBPM(): real {
  return 0.002;
}
fun getMaxBPM(): real {
  return 30000.0;
}


// time: passing by, in seconds, should be positive
// return true upon new beat, false otherwise
// will return trigger upon first call (start with beat)
fun clock(time: real): bool {
  // check if first run (or if reset), since vult init to false
  mem init: bool;
  // beats per minutes
  mem bpm: real;
  // interval between beats, in seconds, for both sub-groups
  mem ibiA: real;
  mem ibiB: real;
  // when last beat occurred
  mem lastBeat: real;
  // how many beats to consider for swing.
  mem groupSize: int;
  // proportion belonging to first sub-group
  mem groupRatio: real;
  // size for first subgroup
  mem subSize: int;
  // where we are in the group
  mem pos: int; 
  // tune IBI, within sub-groups
  mem swing: real;

  val trigger = false;
  // special case, we overflowed the time, or clock is wrong, consider that we should trigger
  if (not(init) || time < lastBeat) {
    init = true;
    lastBeat = time; 
    trigger = true;
    pos = pos + 1;
  }
  // time to clock
  else {
    val ibi;
    if (pos < subSize) {
      ibi = ibiA;
    }
    else {
      ibi = ibiB;
    }
    if (time - lastBeat >= ibi) {
      lastBeat = lastBeat + ibi;
      trigger = true;
      pos = pos + 1;
    }
  }

  pos = pos % groupSize;

  return trigger;
}

// reset position in group, trigger on next call
and reset() {
  init = false;
  pos = 0;
}

// refresh groups and IBI for both groups
and _recompute() {
  // at least one beat in each group (groupSize + 1 for rounding)
  subSize = clip(int(real(groupSize + 1) * groupRatio), 1, groupSize - 1); 
  // base IBI
  val ibi = 60.0/bpm;
  // compress first sub-group
  if (swing <= 0.5) {
    // 1ms minimum IBI
    ibiA = clip(ibi * (swing * 2.0), 0.001, ibi);
    // split IBI for the second sub-group
    ibiB = (real(groupSize) * ibi - ibiA * real(subSize)) / real((groupSize - subSize));
  }
  // same algo there
  else {
    ibiB = clip(ibi * ((1.0 - swing) * 2.0), 0.001, ibi);
    ibiA = (real(groupSize) * ibi - ibiB * real(groupSize - subSize)) / real(subSize);
  }
}

// change current BPM, 0.002 to max 30000 bpm (to deal with fixed float range, and because why not)
and setBPM(newBPM: real) {
  newBPM = clip(newBPM, getMinBPM(), getMaxBPM());
  if (newBPM <> bpm){
    bpm = newBPM;
    _ = _recompute();
  }
}

// set how many beats to consider for swing. Typical swing is size 4 (I would say, for 4/4 signature, with a 2 divider) Clip from 2 (one beat in each sub-group) to 128. Can reset group position if we overflowed new group size.
and setGroupSize(newGroupSize: int) {
  newGroupSize = clip(newGroupSize, 1, 128);
  if (newGroupSize <> groupSize) {
    groupSize = newGroupSize;
    _recompute();
    // in case went already too far this group size
    pos = pos % groupSize;
  }
}

// how to divide the group, 0: one beat for first, rest for second, 0.5: half/half, 1: all but one for first, 1 for second
and setGroupRatio(newGroupRatio: real) {
  newGroupRatio = clip(newGroupRatio, 0.0, 1.0);
  if (newGroupRatio <> groupRatio) {
    groupRatio = newGroupRatio;
    _ = _recompute();
  }
}
// swing ratio, 0: min IBI (1ms) for first sub-group, 1: min for second sub-group. 0.5: neutral. min IBI: 1ms
and setSwing(newSwing: real) {
  newSwing = clip(newSwing, 0.0, 1.0);
  if (swing <> newSwing) {
    swing = newSwing;
    _ = _recompute();
  }
}

and default() @[init] {
  // good ol' 120 BPM
  _ = setBPM(120.0);
  // classical swing for 4/4, combined with divider 2 to get on second beat
  _ = setGroupSize(4);
  _ = setGroupRatio(0.5);
  // no swing at first
  _ = setSwing(0.5);
}


// intput and output (up to 6) normalized from -10/10v to -1/1
fun process() {
  // computing wall clock
  mem time;
  time = time + sampletime();
  // saving current state
  mem lastTrigg;
  mem out1;

  if (cloclo:clock(time)) {
    out1 = 1.0;
    lastTrigg = time;
  }
  // we want 1ms trigger
  else if (time - lastTrigg > 0.001) {
    out1 = 0.0;
  }

  return out1;
}

// called once every 32 loops
and update() {
  // first knob: BPM
  val bpm = clip(getKnob(1) * 1000.0, getMinBPM(), getMaxBPM());
  _ = cloclo:setBPM(bpm);
  // second knob: swing
  _ = cloclo:setSwing(getKnob(2));
  
  // hack to display several things alternatively
  mem disstep;
  disstep = disstep + 1;
  val disfreq = 4000;

  if (disstep % disfreq < disfreq / 2) {
    _ = display("Clock. knob 1 BPM, 2 swing");
  } else {
    _ = display(string(bpm));
  }

}

