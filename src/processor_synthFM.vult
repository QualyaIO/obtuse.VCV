
// from vult utils, convert input voltage normalized from -10..10v to -1..1 to pitch
// output will be limited to 0..127, corresponding to -5v .. +5.583v
fun cvToPitch(cv) : int {
   val pitch = cv * 120.0 + 60.0;
   // round
   if (pitch % 1.0 >= 0.5) {
      pitch = floor(pitch + 1.0);
   } else {
      pitch = floor(pitch);
   }
   pitch = clip(pitch, 0.0, 127.0);
   return int(pitch);
}

fun process(in3:real, in4:real, fs:real) {
   mem param1, param2, param3, param4;

   val out1, out2, out3, out4 = 0.0, 0.0, in3, in4;

   // synthFM -> out1
   out1 = voice:Voice.process();

   return out1, out2, out3, out4;
}
// gate and pitch from CV
// input 1: gate (should normalized -1..1 , gate if >= 0.1, i.e. 1v)
// input 2: v/oct (should normalized -1..1 for -10..10v)
// cable which polyphonic cable is used
// Note: only take into account voct upon new gate
and setNote(gate:real, voct:real, cable:int) {
   // keep track of note and gate per channel (max 16 as per VCV)
   mem last_pitches: array(int, 16);
   mem last_gates: array(bool, 16);
   // note on
   if (not(last_gates[cable]) && gate >= 0.1) {
      last_gates[cable] = true;
      last_pitches[cable] = cvToPitch(voct);
      _ = voice:Voice.noteOn(last_pitches[cable], 127, 0);
   }
   // note off
   else if(last_gates[cable] && gate < 0.1) {
      _ = voice:Voice.noteOff(last_pitches[cable], 0);
      last_gates[cable] = false;
   }
}
and setParam1(knob, mod, input) {
   param1 = clip(knob + mod * input, 0.0, 1.0);
}
and setParam2(knob, mod, input) {
   param2 = clip(knob + mod * input, 0.0, 1.0);
}
and setParam3(knob, mod, input) {
   param3 = clip(knob + mod * input, 0.0, 1.0);
}
and setParam4(knob, mod, input) {
   param4 = clip(knob + mod * input, 0.0, 1.0);
}
and setSamplerate(newFs:real) {
   mem fs;
   if (newFs > 0.0) {
      fs = newFs;
      _ = voice:Voice.setSamplerate(fs);
   }
}
and default() @[init] {
   _ = voice:Voice.default();
   _ = setSamplerate(44.1);
}
