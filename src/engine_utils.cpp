
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "engine_utils.h"

int Gate_compareTimeFract(int time1S, fix16_t time1Fract, int time2S, fix16_t time2Fract){
   while(time1Fract < 0x0 /* 0.000000 */){
      time1S = ((-1) + time1S);
      time1Fract = (0x10000 /* 1.000000 */ + time1Fract);
   }
   while(time1Fract > 0x10000 /* 1.000000 */){
      time1S = (1 + time1S);
      time1Fract = (-0x10000 /* -1.000000 */ + time1Fract);
   }
   while(time2Fract < 0x0 /* 0.000000 */){
      time2S = ((-1) + time2S);
      time2Fract = (0x10000 /* 1.000000 */ + time2Fract);
   }
   while(time2Fract > 0x10000 /* 1.000000 */){
      time2S = (1 + time2S);
      time2Fract = (-0x10000 /* -1.000000 */ + time2Fract);
   }
   if((time1S == time2S) && (time1Fract == time2Fract)){
      return 0;
   }
   else
   {
      if((time1S < time2S) || ((time1S == time2S) && (time1Fract <= time2Fract))){
         return 1;
      }
      else
      {
         return (-1);
      }
   }
}

void Gate__ctx_type_1_init(Gate__ctx_type_1 &_output_){
   Gate__ctx_type_1 _ctx;
   int_init_array(128,0,_ctx.values);
   _ctx.e = 0;
   _ctx.b = 0;
   _output_ = _ctx;
   return ;
}

uint8_t Gate_push(Gate__ctx_type_1 &_ctx, int v){
   if(Gate_getListSpace(_ctx) > 0){
      _ctx.values[_ctx.e] = v;
      _ctx.e = ((1 + _ctx.e) % 128);
      return true;
   }
   return false;
}

int Gate_pop(Gate__ctx_type_1 &_ctx){
   int v;
   v = (-1);
   if(Gate_getListSize(_ctx) > 0){
      v = _ctx.values[_ctx.b];
      _ctx.b = ((1 + _ctx.b) % 128);
   }
   return v;
}

int Gate_peek(Gate__ctx_type_1 &_ctx, int n){
   int v;
   v = (-1);
   if(Gate_getListSize(_ctx) > n){
      v = _ctx.values[((_ctx.b + n) % 128)];
   }
   return v;
}

int Gate_delete(Gate__ctx_type_1 &_ctx, int n){
   int ret;
   ret = (-1);
   int s;
   s = Gate_getListSize(_ctx);
   if(n < s){
      ret = _ctx.values[((_ctx.b + n) % 128)];
      while(n < s){
         _ctx.values[((_ctx.b + n) % 128)] = _ctx.values[((1 + _ctx.b + n) % 128)];
         n = (1 + n);
      }
      _ctx.e = ((127 + _ctx.e) % 128);
   }
   return ret;
}

int Gate_search(Gate__ctx_type_1 &_ctx, int value){
   int idx;
   idx = (-1);
   int s;
   s = Gate_getListSize(_ctx);
   int i;
   i = 0;
   while((i < s) && (idx < 0)){
      if(_ctx.values[((_ctx.b + i) % 128)] == value){
         idx = i;
      }
      i = (1 + i);
   }
   return idx;
}

void Gate__ctx_type_2_init(Gate__ctx_type_2 &_output_){
   Gate__ctx_type_2 _ctx;
   _ctx.timeS = 0;
   _ctx.timeFract = 0x0 /* 0.000000 */;
   int_init_array(128,0,_ctx.notesS);
   Gate__ctx_type_1_init(_ctx.notesOn);
   Gate__ctx_type_1_init(_ctx.notesOff);
   fix_init_array(128,0x0 /* 0.000000 */,_ctx.notesFract);
   Gate__ctx_type_1_init(_ctx.notesActive);
   _ctx.gateDuration = 0x0 /* 0.000000 */;
   Gate_default(_ctx);
   _output_ = _ctx;
   return ;
}

void Gate_process(Gate__ctx_type_2 &_ctx){
   int nbActive;
   nbActive = Gate_getListSize(_ctx.notesActive);
   uint8_t found;
   found = false;
   int i;
   i = 0;
   int note;
   while(bool_not(found) && (i < nbActive)){
      note = Gate_peek(_ctx.notesActive,i);
      if((note >= 0) && (note < 128) && (note < 128)){
         if((Gate_compareTimeFract(_ctx.notesS[note],_ctx.notesFract[note],_ctx.timeS,_ctx.timeFract) >= 0) && (Gate_compareTimeFract((_ctx.timeS + (- _ctx.notesS[note])),(_ctx.timeFract + (- _ctx.notesFract[note])),fix_to_int(_ctx.gateDuration),(_ctx.gateDuration % 0x10000 /* 1.000000 */)) > 0)){
            found = true;
         }
      }
      if(bool_not(found)){
         i = (1 + i);
      }
   }
   while(i > 0){
      note = Gate_pop(_ctx.notesActive);
      if((note >= 0) && (note < 128) && (note < 128)){
         Gate_push(_ctx.notesOff,note);
         _ctx.notesS[note] = 0;
         _ctx.notesFract[note] = 0x0 /* 0.000000 */;
      }
      i = ((-1) + i);
   }
}

uint8_t Gate_noteOn(Gate__ctx_type_2 &_ctx, int note, int velocity, int channel){
   note = int_clip(note,0,127);
   uint8_t newNote;
   newNote = ((_ctx.notesS[note] == 0) && (_ctx.notesFract[note] == 0x0 /* 0.000000 */));
   if(newNote){
      Gate_push(_ctx.notesOn,note);
   }
   else
   {
      Gate_deleteValue(_ctx.notesActive,note);
   }
   _ctx.notesS[note] = _ctx.timeS;
   _ctx.notesFract[note] = _ctx.timeFract;
   Gate_push(_ctx.notesActive,note);
   return newNote;
}

void Trigg__ctx_type_0_init(Trigg__ctx_type_0 &_output_){
   Trigg__ctx_type_0 _ctx;
   bool_init_array(128,false,_ctx.triggers);
   _ctx.ticks = 0;
   _ctx.shift = 0;
   fix_init_array(128,0x0 /* 0.000000 */,_ctx.ptriggers);
   _ctx.position = 0;
   _ctx.n = 0;
   _ctx.magnitude = 0x0 /* 0.000000 */;
   _ctx.length = 0;
   _ctx.isautolength = false;
   _ctx.evolve = 0x0 /* 0.000000 */;
   _ctx.divider = 0;
   _ctx.dirty = false;
   _ctx.density = 0x0 /* 0.000000 */;
   _ctx.balance = 0x0 /* 0.000000 */;
   Trigg_default(_ctx);
   _output_ = _ctx;
   return ;
}

void Trigg__refresh(Trigg__ctx_type_0 &_ctx){
   if(_ctx.dirty || ((_ctx.evolve > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.evolve))){
      int i;
      i = 0;
      while((i < 128) && (i < _ctx.length)){
         if(_ctx.dirty || ((_ctx.magnitude > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.magnitude))){
            _ctx.triggers[i] = ((_ctx.ptriggers[i] > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.ptriggers[i]));
         }
         i = (1 + i);
      }
   }
   _ctx.dirty = false;
}

int Trigg_process(Trigg__ctx_type_0 &_ctx){
   int trig;
   trig = 0;
   _ctx.ticks = (1 + _ctx.ticks);
   if(_ctx.length > 0){
      if((_ctx.divider > 0) && (((_ctx.shift + _ctx.ticks) % _ctx.divider) == 0)){
         if(_ctx.triggers[((_ctx.n + _ctx.position) % _ctx.length)]){
            trig = 1;
         }
         _ctx.n = (1 + _ctx.n);
      }
      if((_ctx.ticks % _ctx.divider) == 0){
         _ctx.ticks = 0;
      }
      if((_ctx.n % _ctx.length) == 0){
         Trigg__refresh(_ctx);
         _ctx.n = 0;
      }
   }
   return trig;
}

void Trigg__recompute(Trigg__ctx_type_0 &_ctx){
   fix16_t mod;
   mod = 0x0 /* 0.000000 */;
   if(_ctx.density > 0x0 /* 0.000000 */){
      mod = fix_div(0x10000 /* 1.000000 */,_ctx.density);
   }
   fix16_t max_p;
   max_p = 0x10000 /* 1.000000 */;
   fix16_t min_p;
   min_p = 0x0 /* 0.000000 */;
   if((mod > 0x10000 /* 1.000000 */) && (_ctx.length > 0)){
      fix16_t fnbplus;
      fnbplus = fix_mul(_ctx.density,int_to_fix(_ctx.length));
      int nbplus;
      nbplus = fix_to_int(fnbplus);
      if((fnbplus % 0x10000 /* 1.000000 */) > 0x200 /* 0.007812 */){
         nbplus = (1 + nbplus);
      }
      int nbminus;
      nbminus = (_ctx.length + (- nbplus));
      fix16_t modp;
      modp = fix_div(int_to_fix(nbplus),int_to_fix(_ctx.length));
      if(modp >= _ctx.density){
         max_p = fix_div(fix_mul(_ctx.density,int_to_fix(_ctx.length)),int_to_fix(nbplus));
      }
      else
      {
         min_p = fix_div(((- int_to_fix(nbplus)) + fix_mul(_ctx.density,int_to_fix(_ctx.length))),int_to_fix(nbminus));
      }
   }
   int imod;
   imod = fix_to_int(mod);
   fix16_t accmod;
   accmod = 0x0 /* 0.000000 */;
   int i;
   i = 0;
   int ci;
   ci = 0;
   uint8_t upmod;
   upmod = false;
   while((i < 128) && (i < _ctx.length)){
      if(imod > 0){
         if(accmod >= 0xfe00 /* 0.992188 */){
            imod = (1 + fix_to_int(mod));
            accmod = (-0x10000 /* -1.000000 */ + accmod);
            upmod = true;
         }
         if((ci % imod) == 0){
            _ctx.ptriggers[i] = (_ctx.density + fix_mul(_ctx.balance,(max_p + (- _ctx.density))));
            if(upmod){
               imod = fix_to_int(mod);
               upmod = false;
            }
            ci = 0;
            accmod = (accmod + (mod % 0x10000 /* 1.000000 */));
         }
         else
         {
            _ctx.ptriggers[i] = (_ctx.density + (- fix_mul(_ctx.balance,(_ctx.density + (- min_p)))));
         }
      }
      else
      {
         _ctx.ptriggers[i] = _ctx.density;
      }
      ci = (1 + ci);
      i = (1 + i);
   }
}

int Trigg__getAutolength(Trigg__ctx_type_0 &_ctx){
   if(_ctx.density <= 0x0 /* 0.000000 */){
      return 0;
   }
   fix16_t mod;
   mod = fix_div(0x10000 /* 1.000000 */,_ctx.density);
   fix16_t autolength;
   autolength = fix_floor(mod);
   int iautolength;
   iautolength = fix_to_int(autolength);
   fix16_t mine;
   mine = 0x200 /* 0.007812 */;
   if((mod % 0x10000 /* 1.000000 */) > mine){
      autolength = fix_mul(mod,fix_div(0x10000 /* 1.000000 */,(mod % 0x10000 /* 1.000000 */)));
      if((autolength % 0x10000 /* 1.000000 */) > mine){
         iautolength = fix_to_int((0x10000 /* 1.000000 */ + autolength));
      }
      else
      {
         iautolength = fix_to_int(autolength);
      }
   }
   return iautolength;
}

uint8_t Trigg__applyLength(Trigg__ctx_type_0 &_ctx, int newLength){
   newLength = int_clip(newLength,0,128);
   if(newLength != _ctx.length){
      _ctx.length = newLength;
      Trigg__recompute(_ctx);
      _ctx.dirty = true;
      if(_ctx.length <= _ctx.n){
         Trigg_restartLoop(_ctx);
      }
      else
      {
         Trigg__refresh(_ctx);
      }
      return true;
   }
   return false;
}

void Trigg_setLength(Trigg__ctx_type_0 &_ctx, int newLength){
   newLength = int_clip(newLength,0,128);
   if((newLength == 0) && bool_not(_ctx.isautolength)){
      _ctx.isautolength = true;
      newLength = Trigg__getAutolength(_ctx);
   }
   else
   {
      if((newLength > 0) && _ctx.isautolength){
         _ctx.isautolength = false;
      }
   }
   Trigg__applyLength(_ctx,newLength);
}

void Trigg_setBalance(Trigg__ctx_type_0 &_ctx, fix16_t newBalance){
   newBalance = fix_clip(newBalance,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newBalance != _ctx.balance){
      _ctx.balance = newBalance;
      Trigg__recompute(_ctx);
      _ctx.dirty = true;
      Trigg__refresh(_ctx);
   }
}

void Trigg_setDensity(Trigg__ctx_type_0 &_ctx, fix16_t newDensity){
   newDensity = fix_clip(newDensity,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newDensity != _ctx.density){
      _ctx.density = newDensity;
      uint8_t update;
      update = true;
      if(_ctx.isautolength){
         update = bool_not(Trigg__applyLength(_ctx,Trigg__getAutolength(_ctx)));
      }
      if(update){
         Trigg__recompute(_ctx);
         _ctx.dirty = true;
         Trigg__refresh(_ctx);
      }
   }
}

void Trigg_default(Trigg__ctx_type_0 &_ctx){
   _ctx.divider = 1;
   _ctx.length = 16;
   _ctx.density = 0x8000 /* 0.500000 */;
   _ctx.balance = 0x8000 /* 0.500000 */;
   _ctx.evolve = 0x3333 /* 0.200000 */;
   _ctx.magnitude = 0x4000 /* 0.250000 */;
   Trigg__recompute(_ctx);
   _ctx.dirty = true;
   Trigg__refresh(_ctx);
}

void Processor_trigg__ctx_type_0_init(Processor_trigg__ctx_type_0 &_output_){
   Processor_trigg__ctx_type_0 _ctx;
   _ctx.trign = 0;
   Trigg__ctx_type_0_init(_ctx.trigg);
   _ctx.tail = 0;
   _ctx.fs = 0x0 /* 0.000000 */;
   Util__ctx_type_3_init(_ctx._inst73b);
   Util__ctx_type_1_init(_ctx._inst551);
   Util__ctx_type_3_init(_ctx._inst43b);
   Util__ctx_type_1_init(_ctx._inst351);
   Util__ctx_type_3_init(_ctx._inst223b);
   Util__ctx_type_3_init(_ctx._inst193b);
   Util__ctx_type_3_init(_ctx._inst163b);
   Util__ctx_type_3_init(_ctx._inst13b);
   Util__ctx_type_3_init(_ctx._inst133b);
   Util__ctx_type_3_init(_ctx._inst103b);
   _output_ = _ctx;
   return ;
}

int Processor_trigg_process(Processor_trigg__ctx_type_0 &_ctx, fix16_t clock, fix16_t reset){
   int trigger;
   trigger = 0;
   if((_ctx.trign > 0) && (_ctx.trign < _ctx.tail)){
      _ctx.trign = (1 + _ctx.trign);
      trigger = 1;
   }
   else
   {
      _ctx.trign = 0;
   }
   if(Util_edge(_ctx._inst351,(reset >= 0x1999 /* 0.100000 */))){
      Trigg_reset(_ctx.trigg);
   }
   if(Util_edge(_ctx._inst551,(clock >= 0x1999 /* 0.100000 */))){
      int newTrigger;
      newTrigger = Trigg_process(_ctx.trigg);
      if(newTrigger > 0){
         trigger = 1;
         _ctx.trign = 1;
      }
   }
   return trigger;
}

void Arp__ctx_type_0_init(Arp__ctx_type_0 &_output_){
   Arp__ctx_type_0 _ctx;
   _ctx.step = 0;
   _ctx.sequenceSize = 0;
   int_init_array(32,0,_ctx.sequence);
   int_init_array(32,0,_ctx.playSequence);
   _ctx.pRandomize = 0x0 /* 0.000000 */;
   _ctx.pRandomNotes = 0x0 /* 0.000000 */;
   int_init_array(16,0,_ctx.notes);
   _ctx.nbNotes = 0;
   _ctx.mode = 0;
   _ctx.dirty = false;
   _output_ = _ctx;
   return ;
}

void Arp_reset(Arp__ctx_type_0 &_ctx){
   if(_ctx.dirty || ((_ctx.pRandomize > 0x0 /* 0.000000 */) && (_ctx.pRandomNotes > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.pRandomize))){
      int i;
      i = 0;
      while(i < _ctx.sequenceSize){
         if((_ctx.pRandomNotes > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.pRandomNotes)){
            _ctx.playSequence[i] = (irandom() % _ctx.nbNotes);
         }
         else
         {
            _ctx.playSequence[i] = _ctx.sequence[i];
         }
         i = (1 + i);
      }
   }
   _ctx.step = 0;
   _ctx.dirty = false;
}

int Arp_process(Arp__ctx_type_0 &_ctx){
   int newNote;
   newNote = _ctx.notes[_ctx.playSequence[_ctx.step]];
   _ctx.step = (1 + _ctx.step);
   if(_ctx.step >= _ctx.sequenceSize){
      Arp_reset(_ctx);
   }
   return newNote;
}

void Arp__updateSequence(Arp__ctx_type_0 &_ctx){
   if((_ctx.mode == 0) || (_ctx.mode == 1)){
      _ctx.sequenceSize = _ctx.nbNotes;
   }
   else
   {
      if((_ctx.mode == 2) || (_ctx.mode == 4)){
         _ctx.sequenceSize = ((-2) + (_ctx.nbNotes << 1));
      }
      else
      {
         if((_ctx.mode == 3) || (_ctx.mode == 5)){
            _ctx.sequenceSize = (_ctx.nbNotes << 1);
         }
      }
   }
   int i;
   i = 0;
   while(i < _ctx.sequenceSize){
      switch(_ctx.mode) {
         case 0:
            _ctx.sequence[i] = i;
         break;
         case 1:
            _ctx.sequence[i] = ((-1) + _ctx.nbNotes + (- i));
         break;
         case 2:
            if(i < _ctx.nbNotes){
               _ctx.sequence[i] = i;
            }
            else
            {
               _ctx.sequence[i] = ((-2) + _ctx.nbNotes + (- (i + (- _ctx.nbNotes))));
            }
         break;
         case 3:
            if(i < _ctx.nbNotes){
               _ctx.sequence[i] = i;
            }
            else
            {
               _ctx.sequence[i] = ((-1) + _ctx.nbNotes + (- (i + (- _ctx.nbNotes))));
            }
         break;
         case 4:
            if(i < _ctx.nbNotes){
               _ctx.sequence[i] = ((-1) + _ctx.nbNotes + (- i));
            }
            else
            {
               _ctx.sequence[i] = (1 + i + (- _ctx.nbNotes));
            }
         break;
         case 5:
            if(i < _ctx.nbNotes){
               _ctx.sequence[i] = ((-1) + _ctx.nbNotes + (- i));
            }
            else
            {
               _ctx.sequence[i] = (i + (- _ctx.nbNotes));
            }
         break;
       
      }
      i = (1 + i);
   }
   _ctx.dirty = true;
   Arp_reset(_ctx);
}

void Arp_setNotes(Arp__ctx_type_0 &_ctx, int (&newNotes)[16]){
   int i;
   i = 0;
   int j;
   j = 0;
   while(i < 16){
      if(newNotes[i] > 0){
         _ctx.notes[j] = int_clip(newNotes[i],0,127);
         j = (1 + j);
      }
      i = (1 + i);
   }
   if(j != _ctx.nbNotes){
      _ctx.nbNotes = j;
      Arp__updateSequence(_ctx);
   }
}

void Arp_setMode(Arp__ctx_type_0 &_ctx, int newMode){
   newMode = int_clip(newMode,0,5);
   if(newMode != _ctx.mode){
      _ctx.mode = newMode;
      Arp__updateSequence(_ctx);
   }
}

void Arp_setPRandomNotes(Arp__ctx_type_0 &_ctx, fix16_t p){
   p = fix_clip(p,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(_ctx.pRandomNotes != p){
      _ctx.pRandomNotes = p;
      _ctx.dirty = true;
   }
}

int Processor_arp_cvToPitch(fix16_t cv){
   fix16_t pitch;
   pitch = (0x3c0000 /* 60.000000 */ + fix_mul(0x780000 /* 120.000000 */,cv));
   if((pitch % 0x10000 /* 1.000000 */) >= 0x8000 /* 0.500000 */){
      pitch = fix_floor((0x10000 /* 1.000000 */ + pitch));
   }
   else
   {
      pitch = fix_floor(pitch);
   }
   pitch = fix_clip(pitch,0x0 /* 0.000000 */,0x7f0000 /* 127.000000 */);
   return fix_to_int(pitch);
}

void Processor_arp__ctx_type_3_init(Processor_arp__ctx_type_3 &_output_){
   Processor_arp__ctx_type_3 _ctx;
   _ctx.note = 0;
   Arp__ctx_type_0_init(_ctx.arpe);
   Util__ctx_type_3_init(_ctx._inst73b);
   Util__ctx_type_3_init(_ctx._inst43b);
   Util__ctx_type_1_init(_ctx._inst351);
   Util__ctx_type_1_init(_ctx._inst151);
   Util__ctx_type_3_init(_ctx._inst13b);
   _output_ = _ctx;
   return ;
}

fix16_t Processor_arp_process(Processor_arp__ctx_type_3 &_ctx, fix16_t trig, fix16_t reset){
   if(Util_edge(_ctx._inst151,(reset >= 0x1999 /* 0.100000 */))){
      Arp_reset(_ctx.arpe);
   }
   if(Util_edge(_ctx._inst351,(trig >= 0x1999 /* 0.100000 */))){
      _ctx.note = Arp_process(_ctx.arpe);
   }
   if(_ctx.note >= 0){
      return Processor_arp_pitchToCv(int_to_fix(_ctx.note));
   }
   else
   {
      return 0x0 /* 0.000000 */;
   }
}

void Tonnetz_getScale(int id, uint8_t (&_output_)[12]){
   uint8_t scale[12];
   {
      scale[0] = false;
      scale[1] = false;
      scale[2] = false;
      scale[3] = false;
      scale[4] = false;
      scale[5] = false;
      scale[6] = false;
      scale[7] = false;
      scale[8] = false;
      scale[9] = false;
      scale[10] = false;
      scale[11] = false;
   }
   switch(id) {
      case 0:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = true;
            scale[3] = true;
            scale[4] = true;
            scale[5] = true;
            scale[6] = true;
            scale[7] = true;
            scale[8] = true;
            scale[9] = true;
            scale[10] = true;
            scale[11] = true;
         }
      break;
      case 1:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 2:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 3:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = false;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 4:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = false;
            scale[6] = true;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 5:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 6:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 7:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = false;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = true;
            scale[7] = false;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 8:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = false;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = false;
            scale[11] = false;
         }
      break;
      case 9:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = false;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 10:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 11:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 12:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = false;
            scale[4] = true;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 13:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 14:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = false;
            scale[3] = true;
            scale[4] = true;
            scale[5] = false;
            scale[6] = true;
            scale[7] = true;
            scale[8] = false;
            scale[9] = true;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 15:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = true;
            scale[3] = true;
            scale[4] = false;
            scale[5] = false;
            scale[6] = true;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = false;
            scale[11] = true;
         }
      break;
      case 16:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = false;
            scale[3] = true;
            scale[4] = true;
            scale[5] = true;
            scale[6] = false;
            scale[7] = true;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 17:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = false;
            scale[3] = true;
            scale[4] = true;
            scale[5] = false;
            scale[6] = true;
            scale[7] = true;
            scale[8] = false;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 18:
         {
            scale[0] = true;
            scale[1] = false;
            scale[2] = false;
            scale[3] = true;
            scale[4] = false;
            scale[5] = true;
            scale[6] = true;
            scale[7] = true;
            scale[8] = false;
            scale[9] = false;
            scale[10] = true;
            scale[11] = false;
         }
      break;
      case 19:
         {
            scale[0] = true;
            scale[1] = true;
            scale[2] = false;
            scale[3] = false;
            scale[4] = true;
            scale[5] = false;
            scale[6] = true;
            scale[7] = false;
            scale[8] = true;
            scale[9] = false;
            scale[10] = true;
            scale[11] = true;
         }
      break;
    
   }
   bool_copy_array(12,_output_,scale);
   return ;
}

void Tonnetz_getChord(int chord, int (&_output_)[3]){
   if(chord > 0){
      chord = (chord % 6);
   }
   switch(chord) {
      case 0:
         {
            int _array_15[3];
            {
               _array_15[0] = 0;
               _array_15[1] = 4;
               _array_15[2] = 8;
            }
            int_copy_array(3,_output_,_array_15);
            return ;
         }
      break;
      case 1:
         {
            int _array_17[3];
            {
               _array_17[0] = 0;
               _array_17[1] = 4;
               _array_17[2] = 7;
            }
            int_copy_array(3,_output_,_array_17);
            return ;
         }
      break;
      case 2:
         {
            int _array_19[3];
            {
               _array_19[0] = 0;
               _array_19[1] = 5;
               _array_19[2] = 7;
            }
            int_copy_array(3,_output_,_array_19);
            return ;
         }
      break;
      case 3:
         {
            int _array_21[3];
            {
               _array_21[0] = 0;
               _array_21[1] = 2;
               _array_21[2] = 7;
            }
            int_copy_array(3,_output_,_array_21);
            return ;
         }
      break;
      case 4:
         {
            int _array_23[3];
            {
               _array_23[0] = 0;
               _array_23[1] = 3;
               _array_23[2] = 7;
            }
            int_copy_array(3,_output_,_array_23);
            return ;
         }
      break;
      case 5:
         {
            int _array_25[3];
            {
               _array_25[0] = 0;
               _array_25[1] = 3;
               _array_25[2] = 6;
            }
            int_copy_array(3,_output_,_array_25);
            return ;
         }
      break;
    default: 
      {
         int _array_27[3];
         {
            _array_27[0] = 0;
            _array_27[1] = 0;
            _array_27[2] = 0;
         }
         int_copy_array(3,_output_,_array_27);
         return ;
      }
   }
}

void Tonnetz_getChordInversion(int chord, int inversion, int (&_output_)[3]){
   inversion = int_clip(inversion,0,2);
   int notes[3];
   Tonnetz_getChord(chord,notes);
   int notesInv[3];
   {
      notesInv[0] = notes[0];
      notesInv[1] = notes[1];
      notesInv[2] = notes[2];
   }
   switch(inversion) {
      case 1:
         {
            notesInv[0] = notes[1];
            notesInv[1] = notes[2];
            notesInv[2] = (12 + notes[0]);
         }
      break;
      case 2:
         {
            notesInv[0] = notes[2];
            notesInv[1] = (12 + notes[0]);
            notesInv[2] = (12 + notes[1]);
         }
      break;
    
   }
   int_copy_array(3,_output_,notesInv);
   return ;
}

void Tonnetz__ctx_type_8_init(Tonnetz__ctx_type_8 &_output_){
   Tonnetz__ctx_type_8 _ctx;
   int_init_array(11,0,_ctx.shifts);
   _ctx.shift = 0;
   _ctx.scaleId = 0;
   bool_init_array(12,false,_ctx.scale);
   _ctx.root = 0;
   _ctx.process_ret_2 = 0;
   _ctx.process_ret_1 = 0;
   _ctx.process_ret_0 = 0;
   _ctx.pJump = 0x0 /* 0.000000 */;
   fix_init_array(3,0x0 /* 0.000000 */,_ctx.inversions);
   _ctx.inversionSpread = 0x0 /* 0.000000 */;
   fix_init_array(6,0x0 /* 0.000000 */,_ctx.chords);
   _ctx.chordSpread = 0x0 /* 0.000000 */;
   _ctx.chord = 0;
   Tonnetz_default(_ctx);
   _output_ = _ctx;
   return ;
}

uint8_t Tonnetz_isChordInShift(Tonnetz__ctx_type_8 &_ctx, int checkChord, int checkShift){
   if(checkChord < 0){
      return false;
   }
   int notes[3];
   Tonnetz_getChord(checkChord,notes);
   return (_ctx.scale[((checkShift + notes[0]) % 12)] && _ctx.scale[((checkShift + notes[1]) % 12)] && _ctx.scale[((checkShift + notes[2]) % 12)]);
}

int Tonnetz_drawChord(Tonnetz__ctx_type_8 &_ctx, uint8_t lookAround){
   fix16_t tChords[6];
   int i;
   i = 0;
   fix16_t curcumP;
   curcumP = 0x0 /* 0.000000 */;
   fix16_t curcumTP;
   curcumTP = 0x0 /* 0.000000 */;
   while(i < 6){
      uint8_t cond;
      cond = Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),_ctx.shift);
      if(lookAround){
         cond = (cond || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(3 + _ctx.shift)) || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(4 + _ctx.shift)) || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(5 + _ctx.shift)) || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(7 + _ctx.shift)) || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(8 + _ctx.shift)) || Tonnetz_isChordInShift(_ctx,(_ctx.chord + i),(9 + _ctx.shift)));
      }
      if(cond){
         tChords[i] = (curcumTP + _ctx.chords[i] + (- curcumP));
         curcumTP = tChords[i];
      }
      else
      {
         tChords[i] = curcumTP;
      }
      curcumP = _ctx.chords[i];
      i = (1 + i);
   }
   if(curcumTP > 0x0 /* 0.000000 */){
      fix16_t pChord;
      pChord = fix_mul(tChords[5],fix_random());
      i = 0;
      while((i < 6) && (pChord > tChords[i])){
         i = (1 + i);
      }
      if(i < 6){
         return ((_ctx.chord + i) % 6);
      }
   }
   return (-1);
}

int Tonnetz_drawInversion(Tonnetz__ctx_type_8 &_ctx){
   fix16_t pInversion;
   pInversion = fix_random();
   int i;
   i = 0;
   while((i < 3) && (pInversion > _ctx.inversions[i])){
      i = (1 + i);
   }
   if(i >= 3){
      i = 0;
   }
   return i;
}

void Tonnetz_process(Tonnetz__ctx_type_8 &_ctx){
   int selectedChord;
   int notes[3];
   if(fix_random() < _ctx.pJump){
      selectedChord = Tonnetz_drawChord(_ctx,true);
      int lookShifts[7];
      {
         lookShifts[0] = 0;
         lookShifts[1] = 3;
         lookShifts[2] = 4;
         lookShifts[3] = 5;
         lookShifts[4] = 7;
         lookShifts[5] = 8;
         lookShifts[6] = 9;
      }
      int selectedShifts[7];
      {
         selectedShifts[0] = (-1);
         selectedShifts[1] = (-1);
         selectedShifts[2] = (-1);
         selectedShifts[3] = (-1);
         selectedShifts[4] = (-1);
         selectedShifts[5] = (-1);
         selectedShifts[6] = (-1);
      }
      int nbShifts;
      nbShifts = 0;
      if(selectedChord >= 0){
         int i;
         i = 0;
         while(i < 7){
            if(Tonnetz_isChordInShift(_ctx,selectedChord,(_ctx.shift + lookShifts[i]))){
               selectedShifts[nbShifts] = lookShifts[i];
               nbShifts = (1 + nbShifts);
            }
            i = (1 + i);
         }
      }
      else
      {
         int_copy_array(7,selectedShifts,lookShifts);
         nbShifts = 7;
      }
      if(nbShifts <= 0){
         int_copy_array(7,selectedShifts,lookShifts);
         nbShifts = 7;
      }
      _ctx.shift = ((_ctx.shift + selectedShifts[(irandom() % nbShifts)]) % 12);
      if(_ctx.shift == 0){
         int i;
         i = 0;
         while(i < 11){
            _ctx.shifts[i] = 0;
            i = (1 + i);
         }
      }
      else
      {
         int i;
         i = 0;
         while((i < 11) && (_ctx.shifts[i] != _ctx.shift) && (_ctx.shifts[i] != 0)){
            i = (1 + i);
         }
         if(i >= 11){
            i = 10;
         }
         _ctx.shifts[i] = _ctx.shift;
         i = (1 + i);
         while(i < 11){
            _ctx.shifts[i] = 0;
            i = (1 + i);
         }
      }
   }
   else
   {
      int i;
      i = 0;
      while((i < 11) && (_ctx.shifts[i] != 0)){
         i = (1 + i);
      }
      if(i > 1){
         _ctx.shifts[((-1) + i)] = 0;
         _ctx.shift = _ctx.shifts[((-2) + i)];
      }
      else
      {
         _ctx.shifts[0] = 0;
         _ctx.shift = 0;
      }
      selectedChord = Tonnetz_drawChord(_ctx,false);
   }
   if(selectedChord < 0){
      Tonnetz_getChord(selectedChord,notes);
      int baseNote;
      baseNote = (_ctx.root + _ctx.shift);
      if(baseNote < 12){
         baseNote = (12 + baseNote);
      }
      else
      {
         if(baseNote > 115){
            baseNote = ((-12) + baseNote);
         }
      }
      notes[0] = ((-12) + baseNote);
      notes[1] = baseNote;
      notes[2] = (12 + baseNote);
   }
   else
   {
      Tonnetz_getChordInversion(selectedChord,Tonnetz_drawInversion(_ctx),notes);
      int i;
      i = 0;
      while(i < 3){
         notes[i] = (_ctx.root + _ctx.shift + notes[i]);
         if(notes[i] > 127){
            notes[i] = ((-12) + notes[i]);
         }
         i = (1 + i);
      }
   }
   _ctx.process_ret_0 = notes[0];
   _ctx.process_ret_1 = notes[1];
   _ctx.process_ret_2 = notes[2];
   return ;
}

void Tonnetz_reset(Tonnetz__ctx_type_8 &_ctx){
   _ctx.shift = 0;
   int i;
   i = 0;
   while(i < 11){
      _ctx.shifts[i] = 0;
      i = (1 + i);
   }
}

void Tonnetz_setScale(Tonnetz__ctx_type_8 &_ctx, int id){
   id = int_clip(id,0,19);
   if(_ctx.scaleId != id){
      _ctx.scaleId = id;
      Tonnetz_getScale(id,_ctx.scale);
      Tonnetz_reset(_ctx);
   }
}

void Tonnetz__updateChords(Tonnetz__ctx_type_8 &_ctx, fix16_t bParam){
   bParam = fix_clip(bParam,0x0 /* 0.000000 */,bParam);
   if(6 == 1){
      _ctx.chords[0] = 0x10000 /* 1.000000 */;
   }
   else
   {
      fix16_t maxi;
      maxi = 0x28000 /* 2.500000 */;
      int i;
      i = 0;
      fix16_t x;
      x = 0x2aaa /* 0.166667 */;
      _ctx.chords[i] = Tonnetz_beta(x,bParam);
      fix16_t chordP;
      chordP = _ctx.chords[i];
      fix16_t scaleP;
      scaleP = 0x0 /* 0.000000 */;
      scaleP = fix_mul(fix_mul(0x3333 /* 0.200000 */,maxi),(0x10000 /* 1.000000 */ + (- chordP)));
      i = (1 + i);
      while(i <= fix_to_int(maxi)){
         x = fix_div(int_to_fix(i),maxi);
         _ctx.chords[i] = (chordP + fix_mul(scaleP,Tonnetz_beta(x,bParam)));
         i = (1 + i);
      }
      while(i < 5){
         x = fix_div((int_to_fix(i) + (- maxi)),maxi);
         _ctx.chords[i] = (0x10000 /* 1.000000 */ + (- fix_mul(scaleP,Tonnetz_beta((0x10000 /* 1.000000 */ + (- x)),bParam))));
         i = (1 + i);
      }
      _ctx.chords[5] = 0x10000 /* 1.000000 */;
   }
}

void Tonnetz__updateInversions(Tonnetz__ctx_type_8 &_ctx, fix16_t bParam){
   bParam = fix_clip(bParam,0x0 /* 0.000000 */,bParam);
   if(3 == 1){
      _ctx.inversions[0] = 0x10000 /* 1.000000 */;
   }
   else
   {
      int maxi;
      maxi = (2 / 2);
      int i;
      i = 0;
      fix16_t x;
      x = 0x5555 /* 0.333333 */;
      _ctx.inversions[i] = Tonnetz_beta(x,bParam);
      fix16_t inversionP;
      inversionP = _ctx.inversions[i];
      fix16_t scaleP;
      scaleP = 0x0 /* 0.000000 */;
      scaleP = (fix_mul(int_to_fix(maxi),(0x10000 /* 1.000000 */ + (- inversionP))) >> 1);
      i = (1 + i);
      while(i <= maxi){
         x = fix_div(int_to_fix(i),int_to_fix(maxi));
         _ctx.inversions[i] = (inversionP + fix_mul(scaleP,Tonnetz_beta(x,bParam)));
         i = (1 + i);
      }
      while(i < 2){
         x = fix_div(int_to_fix((i + (- maxi))),int_to_fix(maxi));
         _ctx.inversions[i] = (0x10000 /* 1.000000 */ + (- fix_mul(scaleP,Tonnetz_beta((0x10000 /* 1.000000 */ + (- x)),bParam))));
         i = (1 + i);
      }
      _ctx.inversions[2] = 0x10000 /* 1.000000 */;
   }
}

void Tonnetz_setChordSpread(Tonnetz__ctx_type_8 &_ctx, fix16_t newSpread){
   newSpread = fix_clip(newSpread,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newSpread != _ctx.chordSpread){
      _ctx.chordSpread = newSpread;
      if(_ctx.chordSpread == 0x0 /* 0.000000 */){
         int i;
         i = 0;
         while(i < 6){
            _ctx.chords[i] = 0x10000 /* 1.000000 */;
            i = (1 + i);
         }
      }
      else
      {
         fix16_t bParam;
         bParam = fix_exp(((0x10000 /* 1.000000 */ + (- newSpread)) << 2));
         Tonnetz__updateChords(_ctx,bParam);
      }
   }
}

void Tonnetz_setInversionSpread(Tonnetz__ctx_type_8 &_ctx, fix16_t newSpread){
   newSpread = fix_clip(newSpread,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newSpread != _ctx.inversionSpread){
      _ctx.inversionSpread = newSpread;
      if(_ctx.inversionSpread == 0x0 /* 0.000000 */){
         int i;
         i = 0;
         while(i < 3){
            _ctx.inversions[i] = 0x10000 /* 1.000000 */;
            i = (1 + i);
         }
      }
      else
      {
         fix16_t bParam;
         bParam = fix_exp(((0x10000 /* 1.000000 */ + (- newSpread)) << 2));
         Tonnetz__updateInversions(_ctx,bParam);
      }
   }
}

fix16_t Tonnetz_getChordP(Tonnetz__ctx_type_8 &_ctx, int chordId){
   chordId = int_clip(chordId,0,6);
   int idx;
   idx = ((chordId + (- _ctx.chord)) % 6);
   if(idx == 0){
      return _ctx.chords[0];
   }
   else
   {
      return (_ctx.chords[idx] + (- _ctx.chords[((-1) + idx)]));
   }
}

void Tonnetz_default(Tonnetz__ctx_type_8 &_ctx){
   _ctx.scaleId = (-1);
   Tonnetz_setScale(_ctx,1);
   Tonnetz_setRoot(_ctx,60);
   Tonnetz_setChord(_ctx,1);
   _ctx.chordSpread = 0x20000 /* 2.000000 */;
   Tonnetz_setChordSpread(_ctx,0x8000 /* 0.500000 */);
   _ctx.inversionSpread = 0x20000 /* 2.000000 */;
   Tonnetz_setInversionSpread(_ctx,0x8000 /* 0.500000 */);
   Tonnetz_setJump(_ctx,0x8000 /* 0.500000 */);
}

int Clock_compareTimeFract(int time1S, fix16_t time1Fract, int time2S, fix16_t time2Fract){
   while(time1Fract < 0x0 /* 0.000000 */){
      time1S = ((-1) + time1S);
      time1Fract = (0x10000 /* 1.000000 */ + time1Fract);
   }
   while(time1Fract >= 0x10000 /* 1.000000 */){
      time1S = (1 + time1S);
      time1Fract = (-0x10000 /* -1.000000 */ + time1Fract);
   }
   while(time2Fract < 0x0 /* 0.000000 */){
      time2S = ((-1) + time2S);
      time2Fract = (0x10000 /* 1.000000 */ + time2Fract);
   }
   while(time2Fract >= 0x10000 /* 1.000000 */){
      time2S = (1 + time2S);
      time2Fract = (-0x10000 /* -1.000000 */ + time2Fract);
   }
   if((time1S == time2S) && (time1Fract == time2Fract)){
      return 0;
   }
   else
   {
      if((time1S < time2S) || ((time1S == time2S) && (time1Fract <= time2Fract))){
         return 1;
      }
      else
      {
         return (-1);
      }
   }
}

void Clock__ctx_type_7_init(Clock__ctx_type_7 &_output_){
   Clock__ctx_type_7 _ctx;
   _ctx.timeS = 0;
   _ctx.timeFract = 0x0 /* 0.000000 */;
   _ctx.ticks = 0;
   _ctx.swing = 0x0 /* 0.000000 */;
   _ctx.subSize = 0;
   _ctx.pos = 0;
   _ctx.orderMix = false;
   _ctx.lastTimeS = 0;
   _ctx.lastTimeFract = 0x0 /* 0.000000 */;
   _ctx.lastTicks = 0;
   _ctx.lastBeatS = 0;
   _ctx.lastBeatFract = 0x0 /* 0.000000 */;
   _ctx.init = false;
   _ctx.ibiB = 0x0 /* 0.000000 */;
   _ctx.ibiA = 0x0 /* 0.000000 */;
   _ctx.ibi = 0x0 /* 0.000000 */;
   _ctx.groupSize = 0;
   _ctx.groupRatio = 0x0 /* 0.000000 */;
   _ctx.bpm = 0x0 /* 0.000000 */;
   Clock_default(_ctx);
   _output_ = _ctx;
   return ;
}

int Clock_process(Clock__ctx_type_7 &_ctx){
   int trigger;
   trigger = 0;
   if(bool_not(_ctx.init) || (Clock_compareTimeFract(_ctx.timeS,_ctx.timeFract,_ctx.lastBeatS,_ctx.lastBeatFract) > 0)){
      _ctx.init = true;
      _ctx.lastBeatS = _ctx.timeS;
      _ctx.lastBeatFract = _ctx.timeFract;
      trigger = 1;
      _ctx.pos = 1;
      _ctx.ibi = _ctx.ibiA;
   }
   else
   {
      if((Clock_compareTimeFract(_ctx.lastTimeS,_ctx.lastTimeFract,_ctx.timeS,_ctx.timeFract) != 0) && (Clock_compareTimeFract((_ctx.timeS + (- _ctx.lastBeatS)),(_ctx.timeFract + (- _ctx.lastBeatFract)),fix_to_int(_ctx.ibi),(_ctx.ibi % 0x10000 /* 1.000000 */)) <= 0)){
         _ctx.lastBeatS = (_ctx.lastBeatS + fix_to_int(_ctx.ibi));
         _ctx.lastBeatFract = (_ctx.lastBeatFract + (_ctx.ibi % 0x10000 /* 1.000000 */));
         while(_ctx.lastBeatFract >= 0x10000 /* 1.000000 */){
            _ctx.lastBeatS = (1 + _ctx.lastBeatS);
            _ctx.lastBeatFract = (-0x10000 /* -1.000000 */ + _ctx.lastBeatFract);
         }
         if((bool_not(_ctx.orderMix) && (_ctx.pos < _ctx.subSize)) || (_ctx.orderMix && ((((_ctx.pos / 2) < _ctx.subSize) && ((_ctx.pos % 2) == 0)) || ((_ctx.pos / 2) > (_ctx.groupSize + (- _ctx.subSize)))))){
            _ctx.ibi = _ctx.ibiA;
            if(_ctx.pos == 0){
               trigger = 1;
            }
            else
            {
               trigger = 2;
            }
         }
         else
         {
            _ctx.ibi = _ctx.ibiB;
            trigger = 3;
         }
         _ctx.pos = (1 + _ctx.pos);
         _ctx.pos = (_ctx.pos % _ctx.groupSize);
      }
   }
   _ctx.lastTimeS = _ctx.timeS;
   _ctx.lastTimeFract = _ctx.timeFract;
   return trigger;
}

void Clock_setTime(Clock__ctx_type_7 &_ctx, int newTimeS, fix16_t newTimeFract){
   _ctx.timeS = newTimeS;
   _ctx.timeFract = newTimeFract;
   while(_ctx.timeFract >= 0x10000 /* 1.000000 */){
      _ctx.timeS = (1 + _ctx.timeS);
      _ctx.timeFract = (-0x10000 /* -1.000000 */ + _ctx.timeFract);
   }
}

void Clock__recompute(Clock__ctx_type_7 &_ctx){
   _ctx.subSize = int_clip(fix_to_int(fix_mul(_ctx.groupRatio,int_to_fix((1 + _ctx.groupSize)))),1,((-1) + _ctx.groupSize));
   uint8_t isIBIA;
   isIBIA = (_ctx.ibi == _ctx.ibiA);
   fix16_t bibi;
   bibi = fix_div(0x3c0000 /* 60.000000 */,_ctx.bpm);
   if(_ctx.swing <= 0x8000 /* 0.500000 */){
      _ctx.ibiA = fix_clip((fix_mul(_ctx.swing,bibi) << 1),0x83 /* 0.002000 */,bibi);
      _ctx.ibiB = fix_div(((- fix_mul(_ctx.ibiA,int_to_fix(_ctx.subSize))) + fix_mul(bibi,int_to_fix(_ctx.groupSize))),int_to_fix((_ctx.groupSize + (- _ctx.subSize))));
   }
   else
   {
      _ctx.ibiB = fix_clip((fix_mul(bibi,(0x10000 /* 1.000000 */ + (- _ctx.swing))) << 1),0x83 /* 0.002000 */,bibi);
      _ctx.ibiA = fix_div(((- fix_mul(_ctx.ibiB,int_to_fix((_ctx.groupSize + (- _ctx.subSize))))) + fix_mul(bibi,int_to_fix(_ctx.groupSize))),int_to_fix(_ctx.subSize));
   }
   if(isIBIA){
      _ctx.ibi = _ctx.ibiA;
   }
   else
   {
      _ctx.ibi = _ctx.ibiB;
   }
}

void Clock_setBPM(Clock__ctx_type_7 &_ctx, fix16_t newBPM){
   newBPM = fix_clip(newBPM,0x4189 /* 0.256000 */,0x75300000 /* 30000.000000 */);
   if(newBPM != _ctx.bpm){
      _ctx.bpm = newBPM;
      Clock__recompute(_ctx);
   }
}

void Clock_setGroupSize(Clock__ctx_type_7 &_ctx, int newGroupSize){
   newGroupSize = int_clip(newGroupSize,2,128);
   if(newGroupSize != _ctx.groupSize){
      _ctx.groupSize = newGroupSize;
      Clock__recompute(_ctx);
      _ctx.pos = (_ctx.pos % _ctx.groupSize);
   }
}

void Clock_setGroupRatio(Clock__ctx_type_7 &_ctx, fix16_t newGroupRatio){
   newGroupRatio = fix_clip(newGroupRatio,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newGroupRatio != _ctx.groupRatio){
      _ctx.groupRatio = newGroupRatio;
      Clock__recompute(_ctx);
   }
}

void Clock_setSwing(Clock__ctx_type_7 &_ctx, fix16_t newSwing){
   newSwing = fix_clip(newSwing,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(_ctx.swing != newSwing){
      _ctx.swing = newSwing;
      Clock__recompute(_ctx);
   }
}

int Clock_getTicks(Clock__ctx_type_7 &_ctx){
   if(Clock_compareTimeFract((_ctx.timeS + (- _ctx.lastBeatS)),(_ctx.timeFract + (- _ctx.lastBeatFract)),fix_to_int(_ctx.ibi),(_ctx.ibi % 0x10000 /* 1.000000 */)) <= 0){
      return _ctx.ticks;
   }
   fix16_t diffS;
   diffS = (_ctx.timeFract + int_to_fix((_ctx.timeS + (- _ctx.lastBeatS))) + (- _ctx.lastBeatFract));
   if(_ctx.ibi > 0x0 /* 0.000000 */){
      return int_clip(fix_to_int(fix_mul(int_to_fix(_ctx.ticks),fix_div(diffS,_ctx.ibi))),0,_ctx.ticks);
   }
   return 0;
}

int Clock_getNbNewTicks(Clock__ctx_type_7 &_ctx){
   int curTicks;
   curTicks = Clock_getTicks(_ctx);
   int newTicks;
   newTicks = (curTicks + (- _ctx.lastTicks));
   if(newTicks < 0){
      newTicks = (newTicks % _ctx.ticks);
   }
   _ctx.lastTicks = curTicks;
   return newTicks;
}

void Clock_default(Clock__ctx_type_7 &_ctx){
   Clock_setBPM(_ctx,0x780000 /* 120.000000 */);
   Clock_setNbTicks(_ctx,24);
   Clock_setGroupSize(_ctx,4);
   Clock_setGroupRatio(_ctx,0x8000 /* 0.500000 */);
   Clock_setSwing(_ctx,0x8000 /* 0.500000 */);
}

void Processor_clock__ctx_type_0_init(Processor_clock__ctx_type_0 &_output_){
   Processor_clock__ctx_type_0 _ctx;
   _ctx.lastTrigg = 0x0 /* 0.000000 */;
   _ctx.gate = false;
   _output_ = _ctx;
   return ;
}

uint8_t Processor_clock_gate1ms(Processor_clock__ctx_type_0 &_ctx, uint8_t trig, fix16_t time){
   if(trig){
      _ctx.lastTrigg = time;
      _ctx.gate = true;
   }
   else
   {
      if((time + (- _ctx.lastTrigg)) > 0x41 /* 0.001000 */){
         _ctx.gate = false;
      }
   }
   return _ctx.gate;
}

void Processor_clock__ctx_type_2_init(Processor_clock__ctx_type_2 &_output_){
   Processor_clock__ctx_type_2 _ctx;
   _ctx.process_ret_4 = 0x0 /* 0.000000 */;
   _ctx.process_ret_3 = 0x0 /* 0.000000 */;
   _ctx.process_ret_2 = 0x0 /* 0.000000 */;
   _ctx.process_ret_1 = 0x0 /* 0.000000 */;
   _ctx.process_ret_0 = 0x0 /* 0.000000 */;
   Clock__ctx_type_7_init(_ctx.cloclo);
   Util__ctx_type_3_init(_ctx._inst73b);
   Processor_clock__ctx_type_0_init(_ctx._inst5d8);
   Processor_clock__ctx_type_0_init(_ctx._inst4d8);
   Util__ctx_type_3_init(_ctx._inst43b);
   Processor_clock__ctx_type_0_init(_ctx._inst3d8);
   Processor_clock__ctx_type_0_init(_ctx._inst2d8);
   Processor_clock__ctx_type_0_init(_ctx._inst1d8);
   Util__ctx_type_3_init(_ctx._inst163b);
   Util__ctx_type_3_init(_ctx._inst13b);
   Util__ctx_type_3_init(_ctx._inst133b);
   Util__ctx_type_3_init(_ctx._inst103b);
   _output_ = _ctx;
   return ;
}

void Processor_clock_process(Processor_clock__ctx_type_2 &_ctx, int timeS, fix16_t timeFract){
   fix16_t out1;
   fix16_t out2;
   fix16_t out3;
   fix16_t out4;
   fix16_t out5;
   Clock_setTime(_ctx.cloclo,timeS,timeFract);
   int ticks;
   ticks = Clock_getNbNewTicks(_ctx.cloclo);
   out5 = Processor_clock_bool2real(Processor_clock_gate1ms(_ctx._inst1d8,(ticks > 0),(timeFract + int_to_fix(timeS))));
   int beat;
   beat = Clock_process(_ctx.cloclo);
   out1 = Processor_clock_bool2real(Processor_clock_gate1ms(_ctx._inst2d8,(beat > 0),(timeFract + int_to_fix(timeS))));
   out2 = Processor_clock_bool2real(Processor_clock_gate1ms(_ctx._inst3d8,(beat == 1),(timeFract + int_to_fix(timeS))));
   out3 = Processor_clock_bool2real(Processor_clock_gate1ms(_ctx._inst4d8,((beat == 1) || (beat == 2)),(timeFract + int_to_fix(timeS))));
   out4 = Processor_clock_bool2real(Processor_clock_gate1ms(_ctx._inst5d8,(beat == 3),(timeFract + int_to_fix(timeS))));
   _ctx.process_ret_0 = out1;
   _ctx.process_ret_1 = out2;
   _ctx.process_ret_2 = out3;
   _ctx.process_ret_3 = out4;
   _ctx.process_ret_4 = out5;
   return ;
}

int Processor_gate_cvToPitch(fix16_t cv){
   fix16_t pitch;
   pitch = (0x3c0000 /* 60.000000 */ + fix_mul(0x780000 /* 120.000000 */,cv));
   if((pitch % 0x10000 /* 1.000000 */) >= 0x8000 /* 0.500000 */){
      pitch = fix_floor((0x10000 /* 1.000000 */ + pitch));
   }
   else
   {
      pitch = fix_floor(pitch);
   }
   pitch = fix_clip(pitch,0x0 /* 0.000000 */,0x7f0000 /* 127.000000 */);
   return fix_to_int(pitch);
}

void Processor_gate__ctx_type_3_init(Processor_gate__ctx_type_3 &_output_){
   Processor_gate__ctx_type_3 _ctx;
   fix_init_array(16,0x0 /* 0.000000 */,_ctx.voctOut);
   bool_init_array(16,false,_ctx.triggers);
   int_init_array(128,0,_ctx.notes);
   _ctx.nbActive = 0;
   fix_init_array(16,0x0 /* 0.000000 */,_ctx.gatesOut);
   Gate__ctx_type_2_init(_ctx.bill);
   Util__ctx_type_3_init(_ctx._inst13b);
   _output_ = _ctx;
   return ;
}

void Processor_gate_process(Processor_gate__ctx_type_3 &_ctx, int timeS, fix16_t timeFract, fix16_t (&triggersCV)[16], fix16_t (&voct)[16], int nbActiveIn){
   int nbMaxActive;
   nbMaxActive = 16;
   Gate_setTime(_ctx.bill,timeS,timeFract);
   int i;
   i = 0;
   while(i < nbActiveIn){
      if(bool_not(_ctx.triggers[i]) && (triggersCV[i] >= 0x1999 /* 0.100000 */)){
         _ctx.triggers[i] = true;
         Gate_noteOn(_ctx.bill,Processor_gate_cvToPitch(voct[i]),0,0);
      }
      else
      {
         if(_ctx.triggers[i] && (triggersCV[i] < 0x1999 /* 0.100000 */)){
            _ctx.triggers[i] = false;
         }
      }
      i = (1 + i);
   }
   Gate_process(_ctx.bill);
   int note;
   note = Gate_getNoteOff(_ctx.bill);
   while((note >= 0) && (note < 128)){
      int out;
      out = _ctx.notes[note];
      if(out > 0){
         _ctx.gatesOut[((-1) + out)] = 0x0 /* 0.000000 */;
         _ctx.voctOut[((-1) + out)] = Processor_gate_pitchToCv(int_to_fix(note));
         _ctx.nbActive = int_clip(((-1) + _ctx.nbActive),0,nbMaxActive);
      }
      note = Gate_getNoteOff(_ctx.bill);
   }
   note = Gate_getNoteOn(_ctx.bill);
   while((note >= 0) && (note < 128)){
      if(_ctx.nbActive < nbMaxActive){
         int outN;
         outN = 0;
         uint8_t findN;
         findN = false;
         while((outN < 16) && bool_not(findN)){
            if(_ctx.gatesOut[outN] == 0x0 /* 0.000000 */){
               findN = true;
            }
            outN = (1 + outN);
         }
         if(findN){
            outN = ((-1) + outN);
            _ctx.notes[note] = (1 + outN);
            _ctx.gatesOut[outN] = 0x10000 /* 1.000000 */;
            _ctx.voctOut[outN] = Processor_gate_pitchToCv(int_to_fix(note));
            _ctx.nbActive = (1 + _ctx.nbActive);
         }
      }
      else
      {
         Gate_noteKill(_ctx.bill,note);
      }
      note = Gate_getNoteOn(_ctx.bill);
   }
}

int Processor_gate_getOutputs(Processor_gate__ctx_type_3 &_ctx, fix16_t (&gatesExt)[16], fix16_t (&voctExt)[16]){
   int nbActiveOut;
   nbActiveOut = 0;
   int i;
   i = 0;
   while(i < 16){
      gatesExt[i] = _ctx.gatesOut[i];
      if(_ctx.gatesOut[i] > 0x0 /* 0.000000 */){
         nbActiveOut = (1 + i);
         voctExt[i] = _ctx.voctOut[i];
      }
      else
      {
         voctExt[i] = 0x0 /* 0.000000 */;
      }
      i = (1 + i);
   }
   return nbActiveOut;
}

int Processor_chord_cvToPitch(fix16_t cv){
   fix16_t pitch;
   pitch = (0x3c0000 /* 60.000000 */ + fix_mul(0x780000 /* 120.000000 */,cv));
   if((pitch % 0x10000 /* 1.000000 */) >= 0x8000 /* 0.500000 */){
      pitch = fix_floor((0x10000 /* 1.000000 */ + pitch));
   }
   else
   {
      pitch = fix_floor(pitch);
   }
   pitch = fix_clip(pitch,0x0 /* 0.000000 */,0x7f0000 /* 127.000000 */);
   return fix_to_int(pitch);
}

void Processor_chord__ctx_type_2_init(Processor_chord__ctx_type_2 &_output_){
   Processor_chord__ctx_type_2 _ctx;
   Tonnetz__ctx_type_8_init(_ctx.ton);
   _ctx.process_ret_2 = 0x0 /* 0.000000 */;
   _ctx.process_ret_1 = 0x0 /* 0.000000 */;
   _ctx.process_ret_0 = 0x0 /* 0.000000 */;
   _ctx.n3 = 0;
   _ctx.n2 = 0;
   _ctx.n1 = 0;
   Util__ctx_type_3_init(_ctx._inst73b);
   Util__ctx_type_3_init(_ctx._inst43b);
   Util__ctx_type_1_init(_ctx._inst351);
   Util__ctx_type_3_init(_ctx._inst163b);
   Util__ctx_type_1_init(_ctx._inst151);
   Util__ctx_type_3_init(_ctx._inst13b);
   Util__ctx_type_3_init(_ctx._inst133b);
   Util__ctx_type_3_init(_ctx._inst103b);
   _output_ = _ctx;
   return ;
}

void Processor_chord_process(Processor_chord__ctx_type_2 &_ctx, fix16_t trig, fix16_t reset){
   if(Util_edge(_ctx._inst151,(reset >= 0x1999 /* 0.100000 */))){
      Tonnetz_reset(_ctx.ton);
   }
   if(Util_edge(_ctx._inst351,(trig >= 0x1999 /* 0.100000 */))){
      Tonnetz_process(_ctx.ton);
      _ctx.n1 = Tonnetz_process_ret_0(_ctx.ton);
      _ctx.n2 = Tonnetz_process_ret_1(_ctx.ton);
      _ctx.n3 = Tonnetz_process_ret_2(_ctx.ton);
   }
   _ctx.process_ret_0 = Processor_chord_pitchToCv(int_to_fix(_ctx.n1));
   _ctx.process_ret_1 = Processor_chord_pitchToCv(int_to_fix(_ctx.n2));
   _ctx.process_ret_2 = Processor_chord_pitchToCv(int_to_fix(_ctx.n3));
   return ;
}

int Processor_chord_getScale(Processor_chord__ctx_type_2 &_ctx, fix16_t (&scale)[12]){
   uint8_t rawScale[12];
   Tonnetz_getScale(Tonnetz_getScaleId(_ctx.ton),rawScale);
   if(12 != 12){
      return 0;
   }
   int root;
   root = Tonnetz_getRoot(_ctx.ton);
   int i;
   i = 0;
   int s;
   s = 0;
   while(i < 12){
      if(rawScale[i]){
         scale[s] = Processor_chord_pitchToCv(int_to_fix((i + root)));
         s = (1 + s);
      }
      i = (1 + i);
   }
   return s;
}


